# -*- coding: utf-8 -*-
"""cpt2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14KQKGyeOnN4BKw-ALhCdrNDut4hR8iUc
"""



"""datastructures
1. arrays
2.string
3.stacks
4.queues
5.linkedlist
6.hashing/hashtables
7.sets
8.trees
9.graphs
10.heaps/priority queue
11. trie - prefix
12. recursion- backtracking using recursion
13. searching algorithms
14. sorting
15. greedy/brute force
1 to 6 linear datastructure
7 to 9 non-linear datastructure
10,11 - abstract datastructure


"""

#aray operationss
'''programto consider a list arr=[10,20,30,40] and perform insert operation with 50 and 25
 at postion 2 respectivelyand, delete 30
 traverse the array to fetch a number  25 is present or not.'''
arr=[10,20,30,40]
#insert
arr.append(50)
arr.insert(2,25)
print(arr)
#deletion
arr.remove(30)
arr.pop()
#print(arr)
#traversal
for i in arr:
  print(i,end=' ')
#searching
print("\n 25 in array?", 25 in arr)

'''program to check whether the given strin is palindrome or not and count the palandromic characters which are repeated count
   str= madam
   output: {'m':2, 'a':2,'d':1}
   str = malayalam'''
text=input("enter the name:")
if text==text[::-1]:
  print("palindrome")
else:
  print("Not")
freq = {}
for i in text:
  freq[i] = freq.get(i,0)+1
print(freq)

"""searchings
linear
binary
sentinel search
fibanacci search
interpolation search

1.linear search:
 in sorted or unsorted arrays
 [45,-9,77,32]
ALGORITHM
 1. array of list  of size n
 2. KEY FOR SEARCH  element
 3. state with zero index value
 4. compare arr[i]==key
          arr[i] = key return index
          else not(move to next index)
 5. repeat same steps till n-1
 6. if no match return -1

              
"""

def linear_search(arr,key):
  for i in range (len(arr)):
    if arr[i]==key:
      return i
  return -1
size = int(input("enter the size of array:"))
arr=[]
print("enter the elements:")
for i in range(size):
  num = int(input(f"element {i+1}:"))
  arr.append(num)
key=int(input("enter the element to search:"))
result= linear_search(arr,key)
if result!=-1:
  print(f"\n element {key} found at {result}")
else:
  print(f"\n element {key} not fond")

"""2. BINARY SEARCH ALGORITHM
  
  1. set low & high 0->n-1
  2. condition low<=high
  3. mid= low+high//2
  4. arr[mid]==key return mid
  5. arr[mid<key low mid+1
  6. arr[mid]>key high mid-1
  7. not found return -1

"""

def binary_search(arr,key):
  low=0
  high = len(arr)-1
  while low<=high:
    mid=(low+high)//2
    if arr[mid]==key:
      return mid
    elif arr[mid]<key:
      low=mid+1
    else:
      high =mid-1
  return -1
size= int(input("enter the size of array:"))

"""JUMP SEARCH

"""

import math
def jump_search(arr,target):
  if not arr:
    return -1
  n=len(arr)
  step=int(math.sqrt(n))
  prev=0
  while prev <n and arr[prev]<target:
    prev+=step
  for i in range(max(0, prev- step),min(n,prev+1)):
    if  arr[i]==target:
      return i
  return -1
arr=[1,3,5,7,9,11]
target=7
result= jump_search(arr,target)
print(f"Element {target} found at index: {result}")

def bsearch_range(arr,target,left,right):
  while left<=right:
    mid=(left+right)//2
    if arr[mid]== target:
       return mid
    elif arr[mid]<target:
      left=mid+1
    else:
      right=mid-1
  return -1
def expo_search(arr,target):
  if not arr:
    return -1
  if arr[0]==target:
    return 0
  n=len(arr)
  i=1
  while i<n and arr[i]<=target:
    i*=2
  return bsearch_range(arr,target,i//2,min(i,n-1))
arr=[2,4,6,8,10,12,14]
target=10
result=expo_search(arr,target)
print(f"element {target} found at index: {result}")

"""FIBANACCI SEARCH

"""

def fibsearch(arr,target):
  if not arr:
    return -1
  n=len(arr)
  fib2=0
  fib1=1
  fib=fib2+fib1
  while fib<n:
    fib2=fib1
    fib1=fib
    fib=fib2+fib1
  offset= -1
  while fib>-1:
    i=min(offset+fib2,n-1)
    if arr[i]==target:
      return i
    elif arr[i]<target:
      fib=fib1
      fib1=fib2
      fib2=fib-fib1
      offset=i
    else:
      fib=fib2
      fib1=fib1-fib2
      fib2=fib-fib1
  if fib== -1 and offset+1<n and arr[offset+1]==target:
    return offset+1
  return -1


arr=[2,4,6,8,10,12]
target= 10
result=fibsearch(arr,target)
print(f"element {target} found at index:{result}")

"""SORTING ALGORITMS
 1. selection
 2. insertion
 3. buble
 4. quick
 5. counting
 6. radix
 7. heap

SELECTION SORT
1. START  from the first element in the list/array
2. arr[0] = min
3. compare with all the remining elements to ffind the real lowest element
4. perform swapping with current position
5. repeat the same with adding positionl values for each,min each
6. for -> 0 to n-1
7.       min=i
8.       for j->i+1 to n:
9.           if arr[j]<(min)
10.             swap
11.             min=i+1
"""

def selection_sort(arr):
  n=len(arr)
  for i in range(n):
    min_index=i
    for j in range(i+1,n):
      if arr[j]arr[min_index]:
        min_index=j
    arr[i],arr[min_index]=arr[min_index],arr[i]
  return arr
size= int(input("enter the number of elements:"))
arr=[]
print("enter",size,"elments")
for _ in range(size):
  num=int(input())
  arr.append(num)
result=selection_sort(arr)
print("sorted array",result)

"""insertion sort:
1. start from the second element (i=1)
2. previous  index valued element check(
3. shift larger element one position to the right
4. insert the current element in the correct position
5. repeat untill list sortd
for i-> 1 to n-1:
  key=arr[i]
  j=i-1
  while j>=0 and arr[j]>key
  arr[j+1]=arr[j].....
  ....
"""

def insertion_sort(arr):
  for i in range(1,len(arr)):
    key = arr[i]
    j=i-1
    while j>=0 and arr[j]>key:
        arr[j+1]=key
        j-=1
    arr[j+1]=key
  return arr
size= int(input("enter the number of elments:"))
arr=[]
print("enter",size,"elements")
for _ in range(size):
  num=int(input())
  arr.append(num)
result= insertion_sort(arr)
print("sorted array:",result)

"""1. sortings
2. bubble
3. counting sort
4. comb sort
5. alrgest unsorted element would be in correct pos
6. repeat pass till all the elements  are sorted

"""

def bubble_sort(arr):
  n=len(arr)
  for i in range(n):
    for j in range(0,n-i-1):
      if arr[j] > arr[j+1]:
        arr[j],arr[j+1]=arr[j+1],arr[j]
size = int(input("enter the no of elements: "))
arr=[]
print("enter the no of elements:")
for _ in range(size):
  arr.append(int(input()))
print("original lsit:",arr)
bubble_sort(arr)
print("bubblesorted:",arr)

"""1. counting sort:
2. if a[j] > a[j+1]
3. swap(a[j],a[j+1])
4. 2-1-1-0-2-5-4-0-2-8-7-7-9-2-0-1-9

"""

def counting_sort(arr):
    max_val = max(arr)
    count = [0] * (max_val + 1)
    for num in arr:
        count[num] += 1
    sorted_arr = []
    for num, freq in enumerate(count):
        sorted_arr.extend([num] * freq)
    return sorted_arr
a = [2,1,1,0,2,5,4,0,2,8,7,7,9,2,0,1,9]

sorted_a = counting_sort(a)
print(sorted_a)

for i in range ()

def csort(arr):
  if not arr:
    return []
  max_val = max(arr)
  count = [0]*(max_val+1)
  for num in arr:
    count[num]+=1
  for i in range(1,len(count)):
    count[i]+=count[i-1]
  output=[0] *len(arr)
  for num in reversed(arr):
    output[count[num]-1] =num
    count[num]-=1
  for i in range(len(output)):
    arr[i]=output[i]
  return arr
arr=[4,2,2,8,3,3,1]
print("before:",arr)
csort(arr)
print("after:",arr)

def csortstring(s):
  count=[0]*26
  for char in s:
    count[ord(char)-ord('a')]+=1
  sorted_str=''
  for i in range(26):
    sorted_str+=chr(i+ord('a')*count[i])
  return sorted_str
name = input("enter a single word:")
sorted_name=csortstring(name)
print("original string:",name)
print("sorted string:", sorted_name)

"""radix sort:
1. find thee maxiu umber to determie umber of dgits
2. sect 10^0,for digitposition
3. increment digit position
4. maxnum//exp>0
5. perform count sort based on current digit
6. (num//exp)%10
7. multiply exp by 10

"""

def count_sort(arr,exp):
  n= len(arr)
  output=[0]*n
  count=[0]*10
  for i in range(n):
    index=(arr[i]//exp)%10
    count[index]+=1
  for i in range(1,10):
    count[i]+=count[i-1]
  i=n-1
  while i>=0:
    index=(arr[i]//exp)%10
    output[count[index]-1]=arr[i]
    count[index]-=1
    i-=1
  for i in range(n):
    arr[i]=output[i]
def radix_sort(arr):
  max_num=max(arr)
  exp=1
  while max_num//exp>0:
    count_sort(arr,exp)
    exp*=10

arr=[170,45,75,90,802,24,2,66]
print("before sort",arr)
radix_sort(arr)
print("after sort",arr)

#pancake problem
def flip(arr, k):
    """Reverse the first k elements of the array."""
    arr[:k] = arr[:k][::-1]

def pancake_sort(arr):
    n = len(arr)
    for size in range(n, 1, -1):
        max_index = arr.index(max(arr[:size]))
        if max_index != size - 1:
            if max_index != 0:
                flip(arr, max_index + 1)
            flip(arr, size)
    return arr
arr = [3, 6, 1, 10, 2, 7]
sorted_arr = pancake_sort(arr)
print("Sorted array:", sorted_arr)

"""1. FILE HANDLING
2. files
"""

